# 多态



> ### 什么是多态

```java
简单的说就是，父类引用指向子类对象，运行期确定调用的方法的版本
与运行期对应的是在类加载的解析阶段会将一部分的符号引用转为直接引用
```



> ### 类加载中的符号引用转换字节引用

```java
这种解析能成立的前提是，放在在程序运行之前就有一个可取定的调用版本，并且这个调用版本在运行期是不可改变的，

哪些方法是确定的？
	静态方法，私有方法，
静态方法是类方法，JVM规定只有类的实例或者类直接调用的 子类也可以访问父类的静态方法，如果运行期间去绑定没有意义，
场景如下：
public class Test {
	static class Father{
		static int a=10;
		static void call(){
			System.out.println(a);
		}
	}
	static class Son extends Father{
		static int a=20;
		static void call(){
			System.out.println(a);
		}
	}
	public static void main(String[] args) {
		Father son=new Son();
		son.call();
	}
}
即时son 的实际类型是Son,但是call() 方法的版本在类编译期就确定了，还可以这么说，在类加载的准备阶段后，解析动作已经能获取到call()方法的入口地址了，因为call是静态方法，只根据静态类型判断


私有方法的调用，也是根据静态类型判断的，因为私有方法是属于类的实例的，就算引用的实际类型在运行期发生改变，JVM会抛出一个无法访问的错误，所以私有方法的调用也是根据变量的静态类型确定的，不用考虑变量在运行期间的实际类型，

还有final 修饰的方法，在编译期绑定的，因为final修饰的方法可以被继承，但是不能被重写，所以子类不可以访问final，所以没了多态的必要，
所以是静态绑定的



那么问题是，类加载阶段的解析，是怎么做到获取私有方法在内存中的的引用的？
	在类加载阶段，准备操作完成后，会创建类的虚方法表，表中存放着该类中所有的方法的入口地址，
		
```



> ### 关于变量的静态类型与动态类型

```java
Human man=new Man(); 
man.call()；
在这里Human 是变量man 的静态类型
Man是变量的实际类型，
换句话说，静态类型是就是编译期所调用的该变量调用方法是合法调用的，能通过编译，因为Human类中的确有call（） 方法，实际类型就是在代码运行中该变量实际引用的实例的类型Man,
```





> 关于重载的方法

```java
重载方法是根据参数的静态数据类型来判断一个方法的调用版本
```



> 重写的方法

```java
每个类在方法区都有一个虚方法表，虚方法表中存放类中各个方法的实际入口地址。
如果某个方法在子类中没有重写，那么子类的虚方法表中的也存有该方法的入口地址，只不过是拷贝父类的该方法的入口地址，
如果子类重写了父类的方法，那么该方法在子类的虚方法表中，只有子类实现的方法的入口地址，

方法表是在类加载的准备阶段后，虚拟机会在方法区中初始化类的方法表
方法表具体在什么地方，在类数据中？


所谓的多态就是 
	Father f=new Son();
	f.call();
在运行阶获取变量f的实际类型，然后根据实际类型的类的虚方法表，然后根据方法签名获取实际调用的方法的引用，
通俗的说就是，运行的时候获取f的实际类型Son，然后到Son的虚方法表中获取所调用方法的入口地址
```



> ### 关于类数据 ，虚方法表

```java
所谓的虚方法表，就是在类加载的时候执行准备动作后，类变量已经分配完成了，就会创建一个虚方法表，所谓的虚方法表就是一个指针数组，数组元素就是该实例的实例方法，其中该类的父类以及超类的所有的没有被重写的实例方法都会在这个表里面，，若子类重写该实例方法，则子类自己的实例方法会替换掉父类的实例方法在该表中的位置
每个类都有自己的虚方法表，抽象类没有

多态的依据就是靠虚方法表实现的，编译期先绑定该方法在方法表中的solt号，然后运行期在找指定的表，
```


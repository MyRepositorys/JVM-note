# 类加载



> ### 什么是类加载

```json
JVM把描述类的数据从Class 文件中'加载'到内存空间，并对数据进行'校验'，转换'解析'，和'初始化'，最终形成可以被虚拟机直接使用的Java类型，这就是JVM的类加载
```



> #### 执行顺序是什么？

```json
JVM 的类加载一共分为5个阶段，按照执行顺序排列分别是加载，验证，准备，解析，初始化，其中因为解析操作发生的时间的不固定，这个顺序不是绝对的，又比如说，在加载进行中的时候，验证动作也开始了，其中验证，准备，解析 又被合在一起叫做连接
所以'加载''连接'的部分动作是交互运行的
```





> #### 加载什么

```json
1.通过一个类的全限定名获取类的class字节码数据的二进制字节流
2.提取该字节码文件中的数据，并在方法去中建立一个数据结构存储这些数据
3.在堆中初始化一个java.lnag.Class类的实例作为，刚加载到方法区中类的数据的访问入口

在JVM 中访问类数据的方式就是通过与该类数据相关的Class类的实例，也就是说Class类的实例有指向该数据结构的指针

其中需要注意的是类，接口都是按照上面的要求加载的，但是数组类，并不是加载器加载的，而是虚拟机直接创建的，当数组的元素是引用类型的时候，JVM在创建数组类后，会去加载该引用类型的class字节码数据

加载了哪些数据?
	'加载'获取到class文件的字节流后会将所有的数据都提取出来，用于验证，符号解析等



关于类加载器的类名称空间？
	一个类加载器加载的所有类的符号引用组成了一个类加载器的类名称空间

```



> #### 验证什么

```json
为什么需要验证：
	class字节码文件的来源并不一定是java代码编译后生成的，使用16进制编辑器也能编辑字节码，代码生成字节码等，所以JVM需要验证class字节码文件的是否符合JVM规范，这是对JVM的一种保护

什么时候验证？
	在上面说过JVM的类加载的每种动作的执行顺序并不是固定的，当'加载'动作获取到class字节码流的时候JVM就开始'验证'动作，

验证谁？
	验证最开始是基于'加载'动作在最开始获取到的class字节码数据流进行验证
	然后基于'加载'动作将字节码数据以某种数据结构存储在方法区中的数据进行验证

验证一共分为四个操作：
	文件格式验证，
	元数据验证
	字节码数据验证
	符号引用验证
验证操作可能会引发其他类的加载，验证，
```



> ###### 文件格式验证

```json
文件格式验证是什么？
	验证'加载'获取到的class字节码数据流的文件格式
	如：
		是否以'0xCAFEBABE'开头？
		'JDK'的版本是否在JVM的处理范围内？
		常量池中的是否存在不被JVM支持的常量（检查常量的tag值）
		class字节码文件中的字节表，方法表，this_class,super_class，interface,以及常量池中的class_info的索引指向常量池的常量的索引，是否在常量池常量项的索引范围内
		CONSTANT_Utf8-info 的字符编码的格式是否存在非法字符
		....
	验证动作不止这些，上面只是列举了一些
	'加载'动作获取到的class字节码文件的数据只有通过'验证'才能把数据以方便查找的数据结构存储在方法区中，才能进行'加载'动作的剩下行为（字节码以某种结构存储在方法区中）
	

紧接着的元数据验证，字节码数据验证，符号引用验证都是基于在'加载'把字节码数据放到方法区中的数据进行验证
```



> ###### 元数据验证

```json
元数据验证是什么？
	元数据验证并不是在'加载'完成后才执行，而是基于刚才说的数据结构，
	元数据验证对字节码描述的信息进行语义分析，确保描述的信息符合Java规范
元数据验证，包括哪些内容？
	这个类是否有父类（除了java.lang.Object类，所有的类或者接口的父类都是java.lang.Object）
	这个类的继承关系中的类是否有final修饰的，（final修饰的类不允许有子类）
	这个类如果不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法
	类中的字段，方法是否与父类产生冲突，如：覆盖了父类中final字段，或者重写了不允许重写的方法，或者重载的方法不符合规则
```



> #### 字节码验证

```json
字节码验证主要目的是通过数据流和控制流分析，确定程序语义是合法的符合逻辑的
```





> #### 符号引用验证

```json
'这个阶段是虚拟机在将符号引用转化为直接引用的时候发生'，问题是什么情况下JVM会将符号引用转换为直接引用呢？

符号引用验证的目的是：
	确保解析动作能正常执行，如果无法通过符号引用验证，则在字节码指令执行的时候排除NoSuchxxxError

符号引用验证是对常量池中的各种除自身以外的符号引用进行匹配性校验
	1.通过符号引用中的全限定名是否能找到对应的类
	2.在本类中引用其他类的成员字段，方法的是否能通过其描述符在对应类中找到描述符相同的字段和方法
	3.符号引用的类，字段，方法的访问权限(private,public,protected)是否可以被当前类访问
符号引用验证在验证的时候是否会导致其他类的加载呢？
	比如在符号引用验证的第二个验证，在本类中使用的其他类的成员字段场景如下：
```

```java
Class B{
    public void main(String...args)
    {
        System.out.println(new A().info)
    }
}
Class A
{
	String info;
	.....
}

符号引用转换为直接引用的时候，符号引用验证的时候，假如说new A().info 这个引用进行验证，怎么验证呢？
首先需要明确的是在类B 的字节码文件中类A的字段info 字段的信息是存储在类B 的常量池的CONSTANT_Fieldref_info中的，如下：
```

![1561349861144](C:\Users\Administrator.MS-201605312249\AppData\Roaming\Typora\typora-user-images\1561349861144.png)

```json
引用验证顺序如下：获取该字段所在类的全限定名，获取该字段简单名称，获取该字段的描述符，然后到类A 中的'类数据'中去用该字段的简单名称，描述符去匹配
```

![1561350344793](C:\Users\Administrator.MS-201605312249\AppData\Roaming\Typora\typora-user-images\1561350344793.png)

![1561350395520](C:\Users\Administrator.MS-201605312249\AppData\Roaming\Typora\typora-user-images\1561350395520.png)

![1561350414321](C:\Users\Administrator.MS-201605312249\AppData\Roaming\Typora\typora-user-images\1561350414321.png)

![1561350457290](C:\Users\Administrator.MS-201605312249\AppData\Roaming\Typora\typora-user-images\1561350457290.png)

![1561350522366](C:\Users\Administrator.MS-201605312249\AppData\Roaming\Typora\typora-user-images\1561350522366.png)



```json
回到刚开始的疑问，符号引用验证在验证的时候是否会导致其他类的加载呢?
	在B 进行验证中的符号引用验证的时候，类B的类数据肯定在加载的时候放到方法区中的，
但是符号引用验证的第二个其他类的字段验证，需要获取类A的类数据，这个类数据如何获取呢？
	需要类A 的类数据肯定会导致类A的class字节码验证的加载，文件格式验证，字节码数据验证，



```



> #### 准备什么？

```json
准备阶段是正式为类变量在方法区中分配内存并设置类变量的初始值的阶段，

'问题是静态变量，或者静态常量是不是和类数据存储在一个地方，还是分别存储的？'

需要注意的是，类变量是类的静态变量或者静态常量，不包括实例变量，实例变量的初始化是随着在堆中创建对象而进行的

类变量的初始化主要目的是给'类变量'分配内存，并把该内存中的二进制清零
这个清零的意思是，基本类型变量的零值，如
int 	0
double	0.0
char	\u0000
引用类型变量的零值是null

需要注意的是如果类变量是静态常量，在准备动作中将类变量的值设置为常量表达式的值，而不是零值，场景如下：
	static final int a=10;
	static int b=10;
那么准备操作会将常量a的内存赋值10，变量b赋值0，变量b的实际值是在类初始化的时候执行<clinit>方法中进行初始化赋值操作的，其中静态代码块，静态变量，都会被

还有一个知识点就是，如果在一个类中使用另外一个类的静态常量，且这个静态常量的赋值语句是常量表达式，静态常量的值是在编译期就可以确定的，
在编译的时候会发生常量传播优化，所谓的传播优化就是，ClassA 中访问ClassB 的静态常量，编译的时候会将ClassB的静态常量值直接编译到指令中，也被称为编译时常量，但是如果静态常量的赋值语句非常量表达式，则不能进行传播优化

在字节码指令执行的时候不会去获取ClassA 的静态常量的值，也不会导致ClassA的加载，验证，准备操作，
场景如下：
```

```java
class A{
	static final int a=10;
	static int b=10;
}
class B{
	public void main(String ...args)
	{
		System.out.println(A.a);
	}
}

我们查看反编译后的main 方法的执行情况
  public void main(java.lang.String...);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_VARARGS
    Code:
      stack=2, locals=2, args_size=2
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: bipush        10
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 8
}
0： getstatic #2	 从常量池第二项获取静态变量out
3： binpush 10	 将常量 10 压入操作数栈
4： invokervirtual # 执行out.println()使用操作数栈中的数据（也就是刚才压入的10）

```

```java
//另外一个场景访问静态变量
class B{
	public void main(String ...args)
	{
		System.out.println(A.b);
	}
}
//反编译后的B 如下：
  public void main(java.lang.String...);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_VARARGS
    Code:
      stack=2, locals=2, args_size=2
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: getstatic     #3                  // Field A.b:I
         6: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
         9: return
      LineNumberTable:
        line 4: 0
        line 5: 9
}
相比上一个访问静态常量，这里多了一个
3: getstatic	#3  访问常量池中索引为3的Fieldref_info 
根据Fieldref_info获取该变量所在类，简单名称，描述符，（至于怎么获取该值，类变量是不是和类数据放在一块就不得而知了，应该是在一块的），'当然这个就会导致，ClassA的加载，验证，准备操作',而使用编译时常量则不会


目前来看，除了访问他类的编译时常量其他操作不会发生解析，其他情况都会发生加载，验证，准备，解析
```





​	



> #### 解析什么？

```java
解析就是运行时常量池的符号引用替换为直接引用，
符号引用用于描述引用的目标，类，字段，方法 符号引用就是字面量，符号引用的目标并不一定加载到内存中，
直接引用：直接引用就是直接指向目标的指针，或者能间接定位到目标的句柄，直接引用的目标，肯定在JVM 管理的内存中，

解析什么什么发生的？
	虚拟机规范并没有规定解析阶段发生的具体时间，只是要求，执行
		anewarry
		checkcast
		getfield
		getstatic
		instanceof
		invokedynamic
		invokeinterface
		invokespecial
		mvokestatic
		invokevirtual
		ldc
		ldc_w
		multianewarray
		new
		putfield
		putstatic
	上述的指令前，JVM需要对使用的符号引用进行解析，也就是各个JVM实现，有可能在类加载后进行后就对常量池中的符号引用进行解析，也有可能是在指令执行前进行解析，但是对于invokedynamic指令而言，符号引用的解析必须等到指令执行的时候才能解析

解析操作肯定会导致其他类的加载，如果不是在指令执行前才解析，那么什么时候对该类的运行时常量池中的符号引用进行解析呢？

	
既然解析就是将有不在内存中的目标的符号引用替换成，在内存中的直接引用，那么解析有可能会导致类的加载，验证，准备，初始化


在解析完成后，会将直接引用存放在该类的运行时常量池中，除了invokedynamic指令，其他指令都是在第一次发起解析请求后，就不会再申请解析了，但是invokedynamic 指令用于动态语言支持的，就是必须等到实际运行指令的时候，解析动作才能执行，


解析动作主要针对类，或者接口，字段，类方法，接口方法，方法类型，方法句柄
```



> #### 初始化什么？

```json
类初始化是类加载的最后一步，初始化的是类数据，而不是实例变量的数据，在准备阶段已经付过一次0值,而在初始化阶段会根据程序员的主观计划去初始化变量，
初始化的执行就是调用<clinit>方法，执行赋值语句，static 代码块，类变量都是在clinit 方法中进行初始化，
而且有趣的是
static{
    b=10;
}
static int b;
静态代码块可以给代码块后面的静态变量赋值，但是不能访问，

静态变量和静态代码块的初始化操作先后赋值，是根据代码中静态代码块和静态变量的定义顺序，

其中重要的是，在子类的类数据初始化之前，要保证父类的的初始化<clinit> 已经执行过了，
接口中也有<clinit>方法，虽然接口中的字段都是静态常量，但是如果接口的字段的赋值表达式非，常量表达式，那么接口字段的初始化也是放在<clinit>中执行的

说起static 代码块有一个特点就是在static 修饰的方法或者静态代码块不能访问实例方法，但是可以调用构造器
比如经典的数据库驱动注册
	首先使用class.forName("driverName")； 将指定的驱动类加载到内存中
	然后具体数据库驱动类的静态代码块中将自己注册到DriverManager,如下：
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException("Can't register driver!");
        }
    }
这有点像观察者模式中观察者在实例化的时候将自己注册到被监听者维护的List中

Class的forName() 方法是静态方法，所以可以使用Class 直接调用，
在类加载中类数据有一个指向Class实例的引用，所以引用名就是class，所以可以使用类名.class
还有一种方式是实例.getClass，这个是继承Obect父类的，该方法是本地方法，还是返回类数据中class 实例引用
三种方式都能调用className() 方法
```



> ### 加载总结

```json
加载只是类加载的第一个动作，在加载执行中，对获取的二进制字节流进行，验证，那么可能导致引用目标类的类加载
解析肯定会导致引用类的加载，验证，准备，初始化
在初始化的时候，会保证其父类的<clinit> 已经执行过了，所以初始化动作也会导致该类的父类以及超类的加载，验证，准备，初始化
```







> ### 用什么加载的

```json
JVM 是使用类加载器去指定的路径加载指定的class字节码文件
```

> ##### 路径是怎么指定的

```java
java虚拟机并没有规定虚拟机应该从哪里寻找类，orcale的Java虚拟机实现根据类路劲搜索类，按照搜索类的先后顺序，类路径可以分为以下3个部分
	启动类路径（jre\lib）
	扩展类路径 (jre\lib\ext)
    用户类路径 （当前类的根目录下开始搜索目标class文件）
```



##### 

### 




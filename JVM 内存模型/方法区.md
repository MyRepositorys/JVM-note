# 方法区



> ### 方法区是什么

```java
装载类型信息存储在一个逻辑上称为方法区的一块JVM管理的内存
方法区是一个总的概念：也就是说所有的的类的类数据都放在里面，并不是数据是混放的，一个类分配一段方法区中的空间，JVM 如何存储类型信息是有设计者决定的
```



> ### 方法区中一个类的数据

```json
有一下类别的数据
	类型数据
	该类的常量池
	字段信息
	方法信息
	类变量
	一个ClassLoader实例的引用
	一个Class类的引用
	方法表
```



> #### 类型数据

```json
	该类的全限定名
	该类的父类的全限定名
	该类是接口还是类类型
	该类的访问标志（ACCESS_FLAG）
	该类实现的接口的全限定名的有序列表
```



> #### 该类对应的常量池

```json
类的源代码中出现的所有的字面量，"字符串"，"数字"
常量池中还存储了
	非本类的定义的类类型
	非本类中定义的字段
	非本来定义的方法
的符号引用
就是在本类中访问了其他类的字段，调用了其他类的方法
比如说场景如下：
class Lava{
    private int speed=5;
void flow(){}
}
class volcano{
    public static void main(Stirng[]args){
        Lava la=new Lava();
		lava.flow();
    }
}
volcano 作为启动类，会首先被加载，验证，准备，初始化，当然父类Object会在volcano装载完成之前被装载
'JVM 会持有volcano常量池的指针',在指向main 方法之前，JVM 会装载Lava类到方法区中，执行一系列操作，然后将指向Lava类数据的指针替换掉volcano常量池的中关于Lava类的引用，，这个过程就是常量池解析
volcano 常量池中还有flow方法的引用，

总而言之该常量池就是保存非本类的字段，方法，类型的符号引用
```



> #### 字段信息

```json
本类中定义的字段名，字段类型，字段的修饰符（access_flag）
```



> #### 方法信息

```json
本类中定义的方法的
	方法的简单名称
	返回值类型
	方法参数的数据和类型
	方法的修饰符（access_flag）
简单的说，就是本类中定义的方法的简单名称和描述符

方法的字节码，操作数栈，局部变量表的大小，异常表
```



> #### 类变量

```json
静态变量，和编译时常量
```



> #### 方法表

```json
虚拟机对每个装载的非抽象类，都生成一个方法表，作为类数据的一部分放在方法区中，
方法表是在类加载中的准备动作结束后，创建的
方法表示一个指针数组，里面是该类的实例方法和从父类继承的实例方法（只有子类没有重写父类的实例方法，才会将父类的实例方法的指针放入表中）的入口指针

```

